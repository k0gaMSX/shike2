
	INCLUDE	BIOS.INC
	INCLUDE	EVENT.INC
	INCLUDE	LEVEL.INC
	INCLUDE	DATA.INC

CHARHEIGHT	EQU	4

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	PUBLIC	CHARINIT
	EXTRN	CARTPAGE,PLACE,ADDAHL,PTRHL,SETCAMOP,CHARSDAT,PUTLPAGE

CHARINIT:
	PUSH	IX
	LD	HL,READY		;INITIALIZE THE LINKED LIST
	LD	(READY+CHAR.NEXT),HL
	LD	(READY+CHAR.PREV),HL
	LD	A,DNODIR		;INITIALIZE USER VARIABLES
	LD	(USERDIR),A
	XOR	A
	LD	(KEYDIR),A

	CALL	PUTLPAGE		;GET CHAR INITIALIZATION DATA FROM
	LD	HL,CHARSDAT		;LEVEL INFO
	LD	IX,CHARBUF
	LD	B,NR_CHARS

C.LOOP:	PUSH	BC
	LD	(C.PTR),HL
	PUSH	HL
	POP	IY
	LD	A,(IY+CINFO.CONTROL)	;TRANSFORM CONTROLLER NUMBER TO FUNCTION
	LD	B,A
	ADD	A,A
	ADD	A,A
	ADD	A,B
	LD	HL,CTRL
	CALL	ADDAHL
	CALL	PTRHL
	LD	B,H
	LD	C,L
	LD	E,(IY+CINFO.PAT)	;E = PATTERN NUMBER
	CALL	CHARACTER		;INITIALIZE CHARACTER
	LD	HL,(C.PTR)
	LD	E,L
	LD	D,H
	LD	BC,CINFO.DIR
	ADD	HL,BC
	LD	C,(HL)
	CALL	PLACE			;PLACE IT IN THE MAP
	LD	DE,SIZCHAR		;NEXT CHARACTER
	ADD	IX,DE
	LD	HL,(C.PTR)
	LD	DE,SIZCINFO
	ADD	HL,DE
	POP	BC
	DJNZ	C.LOOP

	POP	IX
	RET


CTRL:	DW	DUMMY,CS.1
	DB	0
	DW	USER,CS.2
	DB	1
	DW	FOLLOW,CS.3
	DB	2

CS.1:	"DUMMY",0
CS.2:	"USER",0
CS.3:	"FOLLOW",0

	DSEG

C.PTR:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = CHAR CONTROL FUNCTION
;	C = CHAR CONTROL CODE
;OUTPUT: Z = 1 WHEN NO DEFINITION IS FOUND
;	HL = POINTER TO CONTROL INFORMATION

	CSEG
	PUBLIC	CHARCTL
	EXTRN	PTRHL

CHARCTL:LD	IY,CTRL
	EX	DE,HL
	LD	B,NR_CHARCTL

CT.LOOP:LD	A,L
	CP	(IY+CHARCTL.FUN)
	JR	NZ,CT.CODE
	LD	A,H
	CP	(IY+CHARCTL.FUN+1)
	JR	Z,CT.OK

CT.CODE:LD	A,C
	CP	(IY+CHARCTL.CODE)
	JR	Z,CT.OK

	LD	DE,SIZCHARCTL
	ADD	IY,DE
	DJNZ	CT.LOOP
	RET

CT.OK:	PUSH	IY
	POP	HL
	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG

DUMMY:	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO THE CHAR
;	DE = HEAD OF LIST WHERE LINK

	CSEG

LINK:	LD	IYL,E			;IY = HEAD
	LD	IYU,D
	LD	L,E			;HL = HEAD
	LD	H,D
	LD	E,(IY+CHAR.NEXT)	;DE = HEAD->NEXT
	LD	D,(IY+CHAR.NEXT+1)
	LD	C,IXL
	LD	B,IXU			;BC = PTR

	LD	(IY+CHAR.NEXT),C	;HEAD->NEXT = PTR
	LD	(IY+CHAR.NEXT+1),B
	LD	IYL,E
	LD	IYU,D			;IY = HEAD->NEXT

	LD	(IX+CHAR.PREV),L
	LD	(IX+CHAR.PREV+1),H	;PTR->PREV = HEAD
	LD	(IX+CHAR.NEXT),E
	LD	(IX+CHAR.NEXT+1),D	;PTR->NEXT = HEAD->NEXT

	LD	(IY+CHAR.PREV),C
	LD	(IY+CHAR.PREV+1),B	;HEAD->NEXT->PREV = PTR
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO THE CHAR

	CSEG

UNLINK:	LD	C,(IX+CHAR.PREV)
	LD	B,(IX+CHAR.PREV+1)	;BC = PTR->PREV
	LD	E,(IX+CHAR.NEXT)
	LD	D,(IX+CHAR.NEXT+1)	;DE = PTR->NEXT

	LD	IYL,C			;IY = PTR->PREV
	LD	IYU,B
	LD	(IY+CHAR.NEXT),E
	LD	(IY+CHAR.NEXT+1),D	;PTR->PREV->NEXT = PTR->NEXT

	LD	IYL,E			;IY = PTR->NEXT
	LD	IYU,D
	LD	(IY+CHAR.PREV),C
	LD	(IY+CHAR.PREV+1),B	;PTR->NEXT->PREV = PTR->PREV
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	E = PATTERN NUMBER

	CSEG
	PUBLIC	CHARPAT

CHARPAT:LD	A,E			;WE HAVE 4 DIRECTIONS, SO
	CP	4			;EACH PATTERN MEANS MULTIPLY BY 4
	LD	B,0			;WE HAVE 4 PATTERNS IN 0-112
	JR	C,C.1			;AND 4 PATTERNS IN 128-240
	SUB	4
	LD	B,64

C.1:	ADD	A,A
	ADD	A,A
	ADD	A,B
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO THE CHAR
;	E = PATTERN
;	BC = CONTROLLER FUNCTION

	CSEG
	EXTRN	MOVABLE

CHARACTER:
	LD	(IX+CHAR.PAT),E
	PUSH	BC
	CALL	CHARPAT
	OR	80H			;MARK AS ANIMATE OBJECT
	LD	E,A
	LD	C,CHARHEIGHT
	LD	HL,SETRDY
	CALL	MOVABLE
	XOR	A
	LD	(IX+CHAR.ARG1),A
	LD	(IX+CHAR.ARG2),A
	LD	(IX+CHAR.ARG3),A
	POP	HL
	LD	(IX+CHAR.CONTROL),L
	LD	(IX+CHAR.CONTROL+1),H
	LD	DE,READY		;LINK IT IN READY LIST
	JP	LINK

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	PUBLIC	THINK
	EXTRN	PTRCALL

THINK:	XOR	A			;FLAG FOR READING KEYBOARD
	LD	(KBD),A
	PUSH	IX
	LD	DE,(READY+CHAR.NEXT)
	JR	T.ELOOP

T.LOOP:	LD	IXL,E
	LD	IXU,D
	LD	E,(IX+CHAR.NEXT)
	LD	D,(IX+CHAR.NEXT+1)
	PUSH	DE
	LD	L,(IX+CHAR.CONTROL)
	LD	H,(IX+CHAR.CONTROL+1)
	CALL	PTRCALL
	POP	DE

T.ELOOP:LD	HL,READY
	CALL	DCOMPR
	JR	NZ,T.LOOP

T.END:	POP	IX
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO THE CHARACTER

	CSEG

SETRDY:	LD	DE,READY
	JP	LINK


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	A = KEY
;OUTPUT: A = DIRECTION
;	 CY = 1 WHEN E IS NOT A DIRECTIONAL KEY

	CSEG

KEY2DIR:SUB	KB_RIGTH
	JR	C,K.NODIR
	CP	DNODIR
	JR	NC,K.NODIR
	OR	A
	RET

K.NODIR:LD	A,DNODIR
	SCF
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	E = CHAR NUMBER
;OUTPUT:HL = POINTER TO THE N CHAR

	CSEG
	PUBLIC	GETNCHAR
	EXTRN	MULTEA

GETNCHAR:
	LD	A,SIZCHAR
	CALL	MULTEA
	LD	DE,CHARBUF
	ADD	HL,DE
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO THE CHARACTER

	CSEG
	PUBLIC	FOLLOW
	EXTRN	PSEARCH

FOLLOW:	LD	A,(IX+CHAR.ARG2)	;DOES IT HAVE ANY STEP AVAILABLE?
	CP	(IX+CHAR.ARG3)
	JR	Z,F.1
	LD	E,IXL			;TAKE ADDRESS OF IX->PATH
	LD	D,IXU
	LD	HL,CHAR.PATH
	ADD	HL,DE
	LD	A,(IX+CHAR.ARG3)
	CALL	ADDAHL
	INC	(IX+CHAR.ARG3)
	LD	A,(HL)			;A = IX->PATH[IX->ARG3++]
	CALL	STEP
	JP	NZ,UNLINK
	RET

F.1:	LD	E,(IX+CHAR.ARG1)
	CALL	GETNCHAR		;TAKE ADDRESS OF CHARACTER[ARG1]
	PUSH	HL
	POP	IY

	EXTRN	OUTBUF,OUTCNT		;UPDATE OUTBUF AND OUTCNT
	PUSH	IX
	POP	HL
	LD	DE,CHAR.PATH
	ADD	HL,DE
	LD	(OUTBUF),HL
	LD	A,SIZPATH
	LD	(OUTCNT),A

	LD	E,(IX+MOV.RINFO)	;HL = IX->RINFO.HMATRIX
	LD	D,(IX+MOV.RINFO+1)
	LD	A,E
	OR	D
	RET	Z
	LD	HL,RINFO.HMATRIX
	ADD	HL,DE

	LD	E,(IX+MOV.Y)
	LD	D,(IX+MOV.X)
	LD	C,(IY+MOV.Y)
	LD	B,(IY+MOV.X)
	CALL	PSEARCH
	RET	Z			;Z = 1 MEANS NO PATH FOUND

	LD	A,(OUTCNT)
	LD	B,A
	LD	A,SIZPATH
	SUB	B
	RET	Z
	LD	(IX+CHAR.ARG2),A
	LD	(IX+CHAR.ARG3),1
	LD	E,IXL
	LD	D,IXU
	LD	HL,CHAR.PATH
	ADD	HL,DE
	LD	A,(HL)
	CALL	STEP
	JP	NZ,UNLINK
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: IX = POINTER TO THE CHARACTER

	CSEG
	EXTRN	EDITOR,RESETCAM,FINISH,KBHIT,STEP,MAPACTION

USER:	XOR	A			;AVOID 2 CHARS READING THE KEYBOARD
	LD	HL,KBD
	OR	(HL)
	RET	NZ
	INC	(HL)
	CALL	KBHIT
	CP	KB_ESC
	JR	NZ,U.EDIT
	LD	A,1
	LD	(FINISH),A
	RET

U.EDIT:	CP	KB_SELECT
	JR	NZ,U.TELL
	CALL	EDITOR
	JP	RESETCAM

U.TELL:	CP	KB_SPACE
	JR	NZ,U.RELSE
	CALL	MAPACTION
	RET

U.RELSE:BIT	7,A
	JR	Z,U.DIR
	AND	7FH			;REMOVE RELESE MARK
	LD	HL,KEYDIR
	CP	(HL)
	JR	NZ,U.STEP		;RELEASE OF ANOTHER KEY?
	LD	(HL),0
	LD	A,DNODIR
	LD	(USERDIR),A
	RET

U.DIR:	OR	A
	JR	Z,U.STEP		;NO KEY, TEST PREVIOUS KEY
	LD	(KEYDIR),A
	CALL	KEY2DIR			;CHECK IF THE NEW KEY IS DIRECTIONAL
	JR	C,U.STEP
	LD	(USERDIR),A

U.STEP:	LD	A,(USERDIR)		;IF KEYDIR IS NODIR THEN RETURN
	CP	DNODIR
	RET	Z
	CALL	STEP
	JP	NZ,UNLINK
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DSEG
KBD:	DB	0
USERDIR:DB	0			;LAST DIRECTION PRESSED BY USER
KEYDIR:	DB	0			;LAST DIRECTIONAL KEY PRESSED BY USER
READY:	DS	CHAR.PREV+2		;CHARACTERS READY TO RUN
CHARBUF:DS	SIZCHAR*NR_CHARS

