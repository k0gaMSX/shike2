

	INCLUDE	BIOS.INC
	INCLUDE	SHIKE2.INC
	INCLUDE	LEVEL.INC
	INCLUDE	DATA.INC


NR_RINFO	EQU	7		;4 DIRECTIONS,2 DIAGONALS AND CENTER
P1X		EQU	CENTRAL.P1X*16
P1Y		EQU	CENTRAL.P1Y*8

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	INCLUDE	LEVELDEF.INC
	PUBLIC	CHARSDAT,DOORSDAT,FONTGR5,LEVELDEF,MAPDEF,PALETES,CAMDAT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG

	PUBLIC	LEVELINIT

LEVELINIT:
	LD	HL,-1
	LD	(LEVEL),HL		;IN THE BEGINNING WE ARE NOT IN ANY
	LD	(ROOM),HL		;ROOM

	LD	HL,0
	ADD	HL,SP
	LD	(I.STACK),HL
	LD	SP,I.RINFO
	LD	A,-1
	LD	B,NR_RINFO
	LD	IY,RINFO
	LD	DE,SIZRINFO		;INITIALIZE STATIC FIELDS IN RINFO

I.LOOP:	EXX
	POP	HL			;HL = X RENDER
	POP	DE			;DE = Y RENDER
	POP	BC			;BC = ROOM INCREMENT
	LD	(IY+RINFO.XR),L
	LD	(IY+RINFO.XR+1),H
	LD	(IY+RINFO.YR),E
	LD	(IY+RINFO.YR+1),D
	LD	(IY+RINFO.INC),C
	LD	(IY+RINFO.INC+1),B
	LD	(IY+RINFO.ROOM),A	;THIS RINFO IS NOT RENDERING ANY
	LD	(IY+RINFO.ROOM+1),A	;ROOM YET
	EXX
	ADD	IY,DE
	DJNZ	I.LOOP
	LD	HL,(I.STACK)
	LD	SP,HL
	RET

I.RINFO:DW	P1X    ,P1Y    ,00000H	;CENTRAL
	DW	P1X-80H,P1Y-40H,0FF00H	;LEFT
	DW	P1X+80H,P1Y+40H,00100H	;RIGTH
	DW	P1X+80H,P1Y-40H,000FFH	;UP
	DW	P1X-80H,P1Y+40H,00001H	;DOWN
	DW	P1X    ,P1Y-80H,0FFFFH	;LEFT UP
	DW	P1X    ,P1Y+80H,00101H	;RIGTH DOWN

I.REND:

	DSEG
I.STACK:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	PUBLIC	PUTLPAGE
	EXTRN	CARTPAGE

PUTLPAGE:
	LD	E,LEVELPAGE
	JP	CARTPAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: DE = LEVEL COORDENATES
;	BC = ROOM COORDENATES
;OUTPUT:HL = ROOM DATA WHEN IT IS VISIBLE, 0 IN OTHER CASE
;	Z = 1 WHEN IT IS NOT VISIBLE

	CSEG
	PUBLIC	GETRINFO
	EXTRN	ADDAHL

GETRINFO:
	LD	HL,(LEVEL)
	CALL	DCOMPR
	JR	NZ,G.NOK		;DIFFERENT LEVEL, SO NO RINFO

	LD	IY,RINFO
	LD	E,C
	LD	D,B
	LD	B,NR_RINFO

R.LOOP:	LD	A,E			;IS IT THE SAME ROOM?
	CP	(IY+RINFO.ROOM)
	JR	NZ,R.NEXT
	LD	A,D
	CP	(IY+RINFO.ROOM+1)
	JR	NZ,R.NEXT
	PUSH	IY			;OK, RETURN IT
	POP	HL
	OR	1			;SET Z=0
	RET

R.NEXT:	EXX
	LD	DE,SIZRINFO
	ADD	IY,DE
	EXX
	DJNZ	R.LOOP

G.NOK:	LD	HL,0			;I'M SORRY, YOU ARE NOT SHOWED
	CP	A			;SET Z=1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;INPUT:	E = PALETE NUMBER
;OUTPUT:HL = PALETE DATA

	CSEG
	PUBLIC	GETPAL

GETPAL:	EX	DE,HL
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,PALETES
	ADD	HL,DE
	JP	PUTLPAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = LEVEL NUMBER

	CSEG
	PUBLIC	LDLEVEL
	EXTRN	SETPAL,GETLEVEL

LDLEVEL:CALL	GETLEVEL		;GET THE LEVEL DEFINITION STRUCTURE
	RET	Z
	PUSH	HL
	PUSH	HL

	POP	IY
	LD	E,(IY+LVL.PAL)		;SET THE LEVEL PALETE
	CALL	GETPAL
	CALL	SETPAL

	POP	IY
	LD	E,(IY+LVL.GFX)
	CALL	LDPATSET		;LOAD THE LEVEL PATTERN SET
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	E = SET NUMBER

	CSEG
	PUBLIC	LDPATSET
	EXTRN	VLDIR,CARTPAGE

LDPATSET:LD	A,PAT0PAGE
	ADD	A,E
	LD	E,A
	CALL	CARTPAGE		;SET THE PAGE OF THE GRAPHICS
	LD	HL,CARTSEG
	LD	DE,00000H
	LD	BC,04000H
	LD	A,PATPAGE*2
	JP	VLDIR			;COPY THEM TO VRAM (256*128)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = ROOM LOCATION
;OUTPUT:Z = 1 WHEN DE IS NOT CORRECT

	CSEG

CHKROOM:LD	A,-1			;CHECK IF THE ROOM LOCATION IS CORRECT
	CP	D
	RET	Z
	CP	E
	RET	Z
	LD	A,(ROOMYSIZ)
	CP	E
	RET	Z
	LD	A,(ROOMXSIZ)
	CP	D
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: DE = LEVEL POSITION
;	BC = ROOM POSITION
;	HL = MAP POSITION
;	IY = RINFO POINTER
;	A = HEIGHT LEVEL
;OUTPUT:A = HEIGHT VALUE
;	HL = POINTER TO THE HEIGHT VALUE (0 WHEN IS A ROM VALUE)
;	Z = 1 WHEN ERROR

	CSEG
	PUBLIC	GETHEIGHT

GETHEIGHT:
	LD	(G.COOR),HL
	EX	AF,AF'			;A' = HEIGHT LEVEL
	LD	A,IYL
	OR	IYU
	JR	Z,G.NINFO

	EX	AF,AF'			;A = HEIGHT LEVEL
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A			;A = HEIGHT*64 (MAPXSIZ*MAPYSIZ)
	LD	L,A
	LD	H,0			;HL = SIZHMATRIX*HEIGHT

	LD	E,IYL			;DE = RINFO
	LD	D,IYU
	ADD	HL,DE			;HL = RINFO + HMATRIX[HEIGHT]
	LD	DE,RINFO.HMATRIX
	ADD	HL,DE			;HL = RINFO->HMATRIX[HEIGHT]
	EX	DE,HL			;DE = RINFO->HMATRIX[HEIGHT]
	LD	BC,(G.COOR)		;BC = MAP COORDENATES
	LD	L,C			;HL = Y COORDENATE
	LD	H,0
	ADD	HL,HL			;HL = 2*Y
	ADD	HL,HL			;HL = 4*Y
	ADD	HL,HL			;HL = 8*Y
	ADD	HL,DE			;HL = RINFO->HMATRIX[HEIGHT] + 8Y
	LD	E,B			;DE = X COORDENATE
	LD	D,0
	ADD	HL,DE			;HL = RINFO->HMATRIX[HEIGHT] + 8Y + X
	LD	A,(HL)
	CP	-1			;SET Z = 0
	RET

G.NINFO:EX	AF,AF'			;RESTORE INPUT PARAMETERS
	CALL	GETROOM			;HL = POINTER TO MAP ADDRESS
	JR	Z,G.BAD
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			;DE = MAP NUMBER
	LD	A,E
	OR	D
	JR	Z,G.BAD			;DE = MAPNO = 0 MEANS NO ROOM
	CALL	GETHMAP			;HL = HEIGHT ADDRESS (HMAP)
	EX	DE,HL			;DE = HMAP
	LD	BC,(G.COOR)		;BC = MAP COORDENATES
	LD	L,C			;HL = Y COORDENATE
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL			;HL = Y*8
	ADD	HL,DE			;HL = HMAP[Y]
	LD	D,0			;DE = X COORDINATE
	LD	E,B
	ADD	HL,DE			;HL = HMAP[Y][X]
	LD	A,(HL)			;A = HEIGHT VALUE
	LD	HL,G.DUMMY
	CP	-1			;SET Z = 0
	RET

G.BAD:	XOR	A			;SET Z = 1
	RET

	DSEG
G.COOR:	DW	0
G.DUMMY:DB	0			;RETURN THIS ADDRESS WHEN IS A ROM VAL

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = ROOM COORDENATES
;	IY = POINTER TO THE RINFO

	CSEG
	EXTRN	GETROOM

FILLHMATRIX:
	LD	(F.ROOM),DE		;FILL THE HMATRIX OF THE RINFO
	LD	E,IYL
	LD	D,IYU
	LD	HL,RINFO.HMATRIX
	ADD	HL,DE
	EX	DE,HL
	XOR	A

M.LOOPH:LD	(F.HEIGHT),A
	LD	(F.PTR),DE
	LD	DE,(LEVEL)
	LD	BC,(F.ROOM)
	LD	A,(F.HEIGHT)
	CALL	GETROOM			;GET THE MAP NUMBER
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	A,E
	OR	D
	RET	Z			;MAPNO = 0 MEANS EMPTY MAP
	CALL	GETHMAP			;GET THE ADDRESS OF THE HMATRIX
	LD	DE,(F.PTR)
	LD	BC,SIZHMATRIX
	LDIR
	LD	A,(F.HEIGHT)
	INC	A
	CP	NR_HEIGHTS
	JR	NZ,M.LOOPH
	RET

	DSEG
F.HEIGHT:	DB	0
F.ROOM:		DW	0
F.PTR:		DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = LEVEL
;	BC = ROOM

	CSEG
	PUBLIC	FOCUSCAM
	EXTRN	MAP,CLRVPAGE,CPVPAGE,GETHMAP,SHOWDOORS

FOCUSCAM:
	LD	(LEVEL),DE
	LD	(ROOM),BC
	PUSH	DE
	PUSH	BC
	LD	DE,(ACPAGE)
	CALL	CLRVPAGE		;CLEAR ACTIVE PAGE
	POP	BC
	POP	DE
	CALL	MAP			;MAP THE ROOM IN ACTIVE PAGE
	LD	DE,(ACPAGE)
	LD	BC,(DPPAGE)
	CALL	CPVPAGE			;COPY FROM ACTIVE PAGE TO DISPLAY PAGE

	LD	IY,RINFO
	LD	B,NR_RINFO

M.LOOP:	PUSH	BC
	PUSH	IY

	LD	DE,(ROOM)
	LD	L,(IY+RINFO.INC)
	LD	H,(IY+RINFO.INC+1)	;HL=ROOM INCREMENTS
	LD	A,E
	ADD	A,L
	LD	E,A
	LD	A,D
	ADD	A,H
	LD	D,A
	CALL	CHKROOM
	LD	(IY+RINFO.ROOM),E	;DE = NEW ROOM LOCATION
	LD	(IY+RINFO.ROOM+1),D
	CALL	FILLHMATRIX

	POP	IY
	LD	DE,SIZRINFO
	ADD	IY,DE			;IY POINTING TO NEXT RINFO
	POP	BC
	DJNZ	M.LOOP
	CALL	SHOWDOORS		;SHOW THE DOORS IN THE VISIBLE ROOMS
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DSEG

RINFO:	DS	SIZRINFO*NR_RINFO
LEVEL:	DW	0
ROOM:	DW	0



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	PATHFINDER
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = COORDENATE 1
;	BC = COORDENATE 2
;OUTPUT:A = DISTANCE BETWEEN BOTH POINTS
;	Z = 1 WHEN DE == BC
;MODIFY:H

	CSEG
	public	distance

DISTANCE:
	LD	A,D
	SUB	B
	JP	P,D.1
	NEG
D.1:	LD	H,A
	LD	A,E
	SUB	C
	JP	P,D.2
	NEG
D.2:	ADD	A,H
	RET				;A = ABS(P1.X-P2.X) + ABS(P1.Y-P2.Y)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = A POINT
;OUTPUT:Z = 1 WHEN NO VALID NODE

	CSEG
	public	isgood

ISGOOD:	LD	A,D
	CP	-1
	RET	Z
	CP	MAPXSIZ
	RET	Z
	LD	A,E
	CP	-1
	RET	Z
	CP	MAPYSIZ
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = A POINT
;OUTPUT:Z = 1 WHEN NO ACCESSIBLE

	CSEG
	public	isaccess

ISACCESS:
	LD	A,(HEIGHT)
	LD	E,A
	LD	A,(HL)
	SUB	E
	JP	P,A.POS
	NEG
A.POS:	CP	2
	JR	C,A.OK
	XOR	A
	RET
A.OK:	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	HL = MARK POINTER
;	E = DIRECTION OF THIS NODE
;OUTPUT:Z = 1 WHEN NO VALID NODE

	CSEG
	public	ismarked

ISMARKED:
	LD	A,(HL)
	CP	-1
	RET	NZ
	LD	(HL),E			;MARK THIS NODE AS VISITED
	RET				;USE THE DIRECTION

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;OUTPUT:HL = POINTER TO NODE
;	Z = 1 WHEN NO MORE AVAIBLE NODES

	CSEG
	EXTRN	PTRHL
	public	getnode

GETNODE:LD	HL,(BESTP)
	LD	A,H
	OR	L
	JP	Z,G.BADP
	PUSH	HL
	LD	DE,NODE.NEXT		;PTR = BESTP
	ADD	HL,DE			;BESTP = BESTP->NEXT
	CALL	PTRHL
	LD	(BESTP),HL
	LD	A,L
	OR	H
	JP	NZ,G.BEST1
	LD	HL,(BADP)		;IF !BESTP THEN
	LD	DE,(WORSTP)		;   BESTP = BADP
	LD	(BADP),DE		;   BADP = WORSTP
	LD	DE,0			;   WORSTP = TAILP = NULL
	LD	(WORSTP),DE
	LD	(TAILP),DE
G.BEST1:LD	(BESTP),HL
	POP	HL			;RETURN PTR
	OR	1
	RET

G.BADP:	LD	HL,(BADP)
	LD	A,H
	OR	L
	RET	Z			;NO MORE NODES
	PUSH	HL
	LD	DE,NODE.NEXT		;PTR = BADP
	ADD	HL,DE			;BADP = BADP->NEXT
	CALL	PTRHL
	LD	A,L
	OR	H
	JP	NZ,G.BAD1
	LD	HL,(WORSTP)		;IF !BADP THEN
	LD	DE,0			;   BADP = WORSTP
	LD	(WORSTP),DE		;   WORSTP = TAILP = NULL
	LD	(TAILP),DE
G.BAD1:	LD	(BADP),HL
	POP	HL			;RETURN PTR
	OR	1
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = NODE COORDENATES
;	(DESTINE) = DESTINE NODE
;	A = DISTANCE

	CSEG
	public	newnode

NEWNODE:LD	BC,(DESTINE)
	CALL	DISTANCE
	RET	Z			;WE HAVE FOUND THE DESTINE, STOP

	LD	(N.COST),A
	LD	HL,(NODEPTR)
	PUSH	HL
	PUSH	HL
	LD	BC,SIZNODE
	ADD	HL,BC
	LD	(NODEPTR),HL
	POP	HL
	LD	(HL),A			;STORE THE DISTANCE
	INC	HL
	LD	(HL),E			;STORE COORDENATES
	INC	HL
	LD	(HL),D
	INC	HL
	EX	DE,HL			;DE = POINTER TO ACTUAL->NEXT
	POP	BC			;BC = ACTUAL NODE POINTER

	LD	HL,(BESTP)
	LD	A,H
	OR	L
	JP	Z,N.BEST		;BEST IS EMPTY, INSERT
	LD	A,(N.COST)
	CP	(HL)
	JP	Z,N.BEST		;COST <= BESTP->COST, INSERT
	JP	C,N.BEST

	LD	HL,(BADP)
	LD	A,H
	OR	L
	JP	Z,N.BAD			;BAD IS EMPTY, INSERT
	LD	A,(N.COST)
	CP	(HL)
	JP	Z,N.BAD			;COST <= BADP->COST, INSERT
	JP	C,N.BAD

	LD	HL,(WORSTP)
	LD	A,L
	OR	H
	JP	NZ,N.TAIL
	LD	(WORSTP),BC		;IF WORSTP == NULL
	LD	(TAILP),BC		;   TAILP = WORSTP = NODE
	JP	N.AUX			;   NODE->NEXT = NULL

N.TAIL:	LD	IY,(TAILP)		;IF WORSTP != NULL
	LD	(TAILP),BC		;   NODE->NEXT = NULL
	LD	(IY+NODE.NEXT),C	;   TAILP->NEXT = NODE
	LD	(IY+NODE.NEXT+1),B	;   TAILP = NODE
	LD	HL,0
	JP	N.AUX

N.BAD:	LD	(BADP),BC
	JP	N.AUX

N.BEST:	LD	(BESTP),BC

N.AUX:	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	PDEBUG
	OR	1
	RET

	DSEG
N.COST:	DB	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	(NODE) = ACTUAL NODE
;	(HEIGHT) = NODE HEIGHT
;	(HPTR) = ACTUAL HEIGHT POINTER
;	(MPTR) = ACTUAL MARKED POINTER
;	(DESTINE) = DESTINE
;OUTPUT:Z = 1 WHEN WE HAVE REACHED THE DESTINE

	CSEG
	public	addnodes

ADDNODES:
	LD	DE,(NODE)		;IF ISGOOD && ISACCESS && ISMARKED THEN
	INC	D			;   IF NEWNODE == DESTINE THEN
	CALL	ISGOOD			;      RETURN FOUND
	JP	Z,G.LEFT
	LD	HL,(HPTR)
	INC	HL
	CALL	ISACCESS
	JP	Z,G.LEFT
	LD	HL,(MPTR)
	INC	HL
	LD	E,DRIGHT
	CALL	ISMARKED
	JP	NZ,G.LEFT
	LD	DE,(NODE)
	INC	D
	CALL	NEWNODE
	RET	Z

G.LEFT:	LD	DE,(NODE)
	DEC	D
	CALL	ISGOOD
	JP	Z,G.UP
	LD	HL,(HPTR)
	DEC	HL
	CALL	ISACCESS
	JP	Z,G.UP
	LD	HL,(MPTR)
	DEC	HL
	LD	E,DLEFT
	CALL	ISMARKED
	JP	NZ,G.UP
	LD	DE,(NODE)
	DEC	D
	CALL	NEWNODE
	RET	Z

G.UP:	LD	DE,(NODE)
	DEC	E
	CALL	ISGOOD
	JP	Z,G.DOWN
	LD	HL,(HPTR)
	LD	DE,-MAPYSIZ
	ADD	HL,DE
	CALL	ISACCESS
	JP	Z,G.DOWN
	LD	HL,(MPTR)
	LD	DE,-MAPYSIZ
	ADD	HL,DE
	LD	E,DUP
	CALL	ISMARKED
	JP	NZ,G.DOWN
	LD	DE,(NODE)
	DEC	E
	CALL	NEWNODE
	RET	Z

G.DOWN:	LD	DE,(NODE)
	INC	E
	CALL	ISGOOD
	JP	Z,G.NEND
	LD	HL,(HPTR)
	LD	DE,MAPYSIZ
	ADD	HL,DE
	CALL	ISACCESS
	JP	Z,G.NEND
	LD	HL,(MPTR)
	LD	DE,MAPYSIZ
	ADD	HL,DE
	LD	E,DDOWN
	CALL	ISMARKED
	RET	NZ
	LD	DE,(NODE)
	INC	E
	CALL	NEWNODE
	RET

G.NEND:	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = ORIGIN
;	BC = DESTINE
;	HL = HEIGHT MATRIX


	CSEG
	PUBLIC	PSEARCH
	EXTRN	MEMSET

PSEARCH:LD	(P.MATRIX),HL
	LD	(DESTINE),BC		;INITIALIZE DESTINE
	LD	HL,0
	LD	(BESTP),HL		;AND DATA POINTERS
	LD	(BADP),HL
	LD	(WORSTP),HL
	LD	(TAILP),HL
	PUSH	DE
	LD	HL,NODEBUF
	LD	(NODEPTR),HL
	LD	HL,MARKBUF		;CLEAR MARK BUF
	LD	BC,MAPYSIZ*MAPXSIZ
	LD	A,-1
	CALL	MEMSET
	POP	DE

	LD	A,E			;TODO: REMOVE THIS PART. IT IS ONLY
	ADD	A,A			;FOR TESTING
	ADD	A,A
	ADD	A,A
	ADD	A,D
	LD	HL,(P.MATRIX)
	CALL	ADDAHL
	LD	(HL),0
;;;
	LD	(ORIGIN),DE
	LD	A,E
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,D
	LD	B,A
	LD	HL,MARKBUF
	CALL	ADDAHL
	LD	(HL),DNODIR
	LD	(NODE),DE
	JP	P.MARK

P.LOOP:	LD	(NODE),DE
	LD	A,E
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,D
	LD	B,A
	LD	HL,MARKBUF
	CALL	ADDAHL
P.MARK:	LD	(MPTR),HL		;MPTR = MARKBUF + Y*MAPYSIZ + X

	LD	HL,(P.MATRIX)
	LD	A,B
	CALL	ADDAHL
	LD	(HPTR),HL		;HPTR = P.MATRIX + Y*MAPYSIZ + X
	LD	A,(HL)
	LD	(HEIGHT),A

	CALL	PDEBUG
	CALL	ADDNODES
	JP	NZ,P.NEXT
	CALL	PSHOW
	OR	1
	RET

P.NEXT:	CALL	GETNODE			;GET THE BEST NODE
	RET	Z
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	JP	P.LOOP

	DSEG
P.MATRIX:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	EXTRN	PUTS
	public	pshow

PSHOW:	LD	A,(ACPAGE)
	PUSH	AF
	LD	A,(DPPAGE)
	LD	(ACPAGE),A
	LD	E,A
	CALL	CLRVPAGE
	LD	DE,0
	CALL	LOCATE
	LD	DE,(DESTINE)
	CALL	PXXX
	CALL	VDPSYNC
	CALL	KPRESS
	POP	AF
	LD	(ACPAGE),A
	RET

PXXX:	LD	HL,(ORIGIN)
	CALL	DCOMPR
	RET	Z

	LD	A,E
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,D
	LD	HL,MARKBUF
	CALL	ADDAHL
	LD	A,(HL)

X.RIGHT:CP	DRIGHT
	JR	NZ,X.LEFT
	DEC	D
	CALL	PXXX
	LD	DE,S.RIGHT
	JP	PUTS
S.RIGHT:DB	"RIGHT",10,0

X.LEFT:	CP	DLEFT
	JR	NZ,X.UP
	INC	D
	CALL	PXXX
	LD	DE,S.LEFT
	JP	PUTS
S.LEFT:	DB	"LEFT",10,0

X.UP:	CP	DUP
	JR	NZ,X.DOWN
	INC	E
	CALL	PXXX
	LD	DE,S.UP
	JP	PUTS
S.UP:	DB	"UP",10,0

X.DOWN:	CP	DDOWN
	JR	NZ,X.ERR
	DEC	E
	CALL	PXXX
	LD	DE,S.DOWN
	JP	PUTS
S.DOWN:	DB	"DOWN",10,0

X.ERR:	LD	DE,S.ERR
	JP	PUTS
S.ERR:	DB	"ERROR",10,0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	EXTRN	CLRVPAGE,LOCATE,PRINTF,VDPSYNC,KPRESS

	INCLUDE	BIOS.INC
	public	pdebug

PDEBUG:	LD	A,(ACPAGE)
	PUSH	AF
	LD	A,(DPPAGE)
	LD	(ACPAGE),A
	LD	E,A
	CALL	CLRVPAGE

	LD	DE,0
	CALL	LOCATE

	LD	HL,(TAILP)
	PUSH	HL
	LD	HL,(WORSTP)
	PUSH	HL
	LD	HL,(BADP)
	PUSH	HL
	LD	HL,(BESTP)
	PUSH	HL
	LD	DE,(NODE)
	LD	H,0
	LD	L,E
	PUSH	HL
	LD	L,D
	PUSH	HL
	LD	DE,P.FMT1
	CALL	PRINTF

	LD	DE,1
	LD	IY,(BESTP)
	CALL	P.AUX

	LD	DE,20*256+1
	LD	IY,(BADP)
	CALL	P.AUX

	LD	DE,40*256+1
	LD	IY,(WORSTP)
	CALL	P.AUX

	CALL	VDPSYNC
	CALL	KPRESS
	POP	AF
	LD	(ACPAGE),A
	RET

P.FMT1:	DB	"NODE=%02dX%02d,BEST=%x,BAD=%x,WORST=%x,TAIL=%x",0

P.AUX:	LD	A,IYL
	OR	IYU
	RET	Z

	PUSH	DE
	PUSH	IY
	PUSH	IY
	CALL	LOCATE
	POP	IY
	LD	B,0
	LD	C,(IY+NODE.Y)
	PUSH	BC
	LD	C,(IY+NODE.X)
	PUSH	BC
	LD	C,(IY+NODE.COST)
	PUSH	BC
	LD	DE,P.FMT2
	CALL	PRINTF

	POP	IY
	LD	E,(IY+NODE.NEXT)
	LD	D,(IY+NODE.NEXT+1)
	LD	IYL,E
	LD	IYU,D
	POP	DE
	INC	E
	JR	P.AUX

P.FMT2:	DB	"C=%02d,P=%02dX%02d--",0


;;;;;;;;;;;;

NODE.COST	EQU	0
NODE.Y		EQU	NODE.COST+1
NODE.X		EQU	NODE.Y+1
NODE.NEXT	EQU	NODE.X+1
SIZNODE		EQU	NODE.NEXT+2


	DSEG
	PUBLIC	MARKBUF,NODEBUF

NODE:	DW	0
HEIGHT:	DB	0
HPTR:	DW	0
MPTR:	DW	0
ORIGIN:	DW	0
DESTINE:DW	0
NODEPTR:DW	0
BESTP:	DW	0
BADP:	DW	0
WORSTP:	DW	0
TAILP:	DW	0
MARKBUF:DS	MAPXSIZ*MAPYSIZ
NODEBUF:DS	SIZNODE*MAPXSIZ*MAPYSIZ


