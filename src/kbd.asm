	INCLUDE	SHIKE2.INC
	INCLUDE	BIOS.INC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: 	E = KEYCODE + UPPER BIT (UP/DOWN)

	CSEG

KEYEVENT:
	LD	BC,(QPOINTER)	; C = IN, B = OUT
	LD	A,C
	INC	A
	AND	NR_KEYBUF - 1	;NR_KEYBUF MUST BE A POWER OF 2
	CP	B
	RET	Z		;NO ROOM FOR NEW KEYCODE

	EX	AF,AF'		;SAVE NEXT POSITION
	LD	A,C
	LD	HL,QUEUE
	ADD	A,L
	LD	L,A
	JR	NC,.NOINC
	INC	HL
.NOINC:	LD	(HL),E		;STORE KEYCODE
	EX	AF,AF'		;RESTORE NEXT POSITION
	LD	C,A
	LD	(QPOINTER),BC
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;OUTPUT:	A = KEYCODE

	CSEG
	PUBLIC	GETCHAR

GETCHAR:
	CALL	GETCH
	JR	Z,.SLEEP
	BIT	7,A
	JR	NZ,GETCHAR      ;KEY RELEASE, WE ONLY WANT PRESS
	RET

.SLEEP:	EI
	HALT                    ;SLEEP A FRAME
	JR	GETCHAR         ;AND TRY AGAIN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;OUTPUT:      A = KEYCODE OR 0 IF EMPTY QUEUE

	CSEG
        PUBLIC	GETCH

GETCH:
	DI			;TODO: USE A MUTEX VARIABLE INSTEAD OF DI
	LD	BC,(QPOINTER)	;C = IN, B = OUT
	LD	A,B
	CP	C
	JR	NZ,.GETCH
        EI
	XOR	A		;NO DATA IN THE QUEUE
	RET			;Z FLAG IS RESET

.GETCH:	
	LD	HL,QUEUE
	LD	A,B
	ADD	A,L
	LD	L,A
	JR	NC,.GTCH_NOINC
	INC	HL		;POINT THE CORRECT BYTE IN THE QUEUE

.GTCH_NOINC:
	LD	A,B
	INC	A
	AND	NR_KEYBUF - 1	;NR_KEYBUF MUST BE A POWER OF 2
	LD	B,A		;UPDATE THE OUT COUNTER
	LD	(QPOINTER),BC
	LD	A,(HL)
	OR	A		;SET Z FLAG
        EI
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; INPUT:      C = XOR`ED KEYBOARD STATUS
;	B = KEYBOARD STATUS
;	(KEYCODE) = INITIAL KEYCODE

	CSEG

SCANROW:
	LD	A,(KEYCODE)
	LD	E,A

.SCANLOOP:
	XOR	A
	OR	C
	RET	Z		;NO MORE ACTIVATED FLAGS
	RLCA
	JR	NC,.NOBIT	;THIS KEYCODE IS NOT ACTIVATED

	PUSH	BC
	PUSH	DE
	LD	A,B
	CPL
	AND	80H
	OR	E
	LD	E,A
	CALL	KEYEVENT
	POP	DE
	POP	BC

.NOBIT:
	SLA	B
	SLA	C
	INC	E
	JR	.SCANLOOP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
        PUBLIC	KBDHOOK

KBDHOOK:
	DI
	LD	A,1
	LD	(KEYCODE),A
	LD	HL,ROWBUF
	LD	D,0

.HOOKLOOP:
	PUSH	HL
	PUSH	DE
	LD	A,D
	CALL	SNMAT		;TAKE ROW STATUS
	CPL
	LD	B,A
	LD	C,(HL)		;UPDATE PREVIOUS STATUS
	LD	(HL),A		;A = B = ACTUAL, C = PREV
	XOR	C
	LD	C,A
	CALL	NZ,SCANROW	;A = C = ACTUAL ^ PREV, B = PREV
	POP	DE
	POP	HL

	LD	A,(KEYCODE)	;INCREMENT KEYCODE BY 8
	ADD	A,8
	LD	(KEYCODE),A
	INC	HL		;NEXT ROW POSITION
	INC	D
	LD	A,D
	CP	NR_ROW
	JR	NZ,.HOOKLOOP
	RET

	DSEG

KEYCODE:	DB	0	;ACTUAL KEYCODE
QPOINTER:	DW	0	;QUEUE POINTER
QUEUE:		DS	NR_KEYBUF	;QUEUE BUFFER
ROWBUF:		DS	NR_ROW		;ROW BUFFER
