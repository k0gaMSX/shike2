

	INCLUDE	BIOS.INC
	INCLUDE	SHIKE2.INC
	INCLUDE	LEVEL.INC
	INCLUDE	DATA.INC

;LEVEL IS AN OBSOLETE NAME. EXTERNALLY THE TERM NEIGHBOORHOOD
;IS USED BECAUSE IT IS BETTER.

NR_RINFO	EQU	7		;4 DIRECTIONS,2 DIAGONALS AND CENTER
P1X		EQU	CENTRAL.P1X*16
P1Y		EQU	CENTRAL.P1Y*8

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	INCLUDE	LEVELDEF.INC
	PUBLIC	CHARSDAT,DOORSDAT,FONTGR5,LEVELDEF,MAPDEF,PALETES,CAMDAT
	PUBLIC	GLOBEDEF,WHITEDEF,FONTSPR,OBJDAT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG

	PUBLIC	LEVELINIT

LEVELINIT:
	LD	HL,-1
	LD	(LEVEL),HL		;IN THE BEGINNING WE ARE NOT IN ANY
	LD	(ROOM),HL		;ROOM

	LD	HL,0
	ADD	HL,SP
	LD	(I.STACK),HL
	LD	SP,I.RINFO
	LD	A,-1
	LD	B,NR_RINFO
	LD	IY,RINFO
	LD	DE,SIZRINFO		;INITIALIZE STATIC FIELDS IN RINFO

I.LOOP:	EXX
	POP	HL			;HL = X RENDER
	POP	DE			;DE = Y RENDER
	POP	BC			;BC = ROOM INCREMENT
	LD	(IY+RINFO.XR),L
	LD	(IY+RINFO.XR+1),H
	LD	(IY+RINFO.YR),E
	LD	(IY+RINFO.YR+1),D
	LD	(IY+RINFO.INC),C
	LD	(IY+RINFO.INC+1),B
	LD	(IY+RINFO.ROOM),A	;THIS RINFO IS NOT RENDERING ANY
	LD	(IY+RINFO.ROOM+1),A	;ROOM YET
	EXX
	ADD	IY,DE
	DJNZ	I.LOOP
	LD	HL,(I.STACK)
	LD	SP,HL
	RET

I.RINFO:DW	P1X    ,P1Y    ,00000H	;CENTRAL
	DW	P1X-80H,P1Y-40H,0FF00H	;LEFT
	DW	P1X+80H,P1Y+40H,00100H	;RIGTH
	DW	P1X+80H,P1Y-40H,000FFH	;UP
	DW	P1X-80H,P1Y+40H,00001H	;DOWN
	DW	P1X    ,P1Y-80H,0FFFFH	;LEFT UP
	DW	P1X    ,P1Y+80H,00101H	;RIGTH DOWN

I.REND:

	DSEG
I.STACK:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	PUBLIC	PUTLPAGE
	EXTRN	CARTPAGE

PUTLPAGE:
	LD	E,LEVELPAGE
	JP	CARTPAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: DE = LEVEL COORDENATES
;	BC = ROOM COORDENATES
;OUTPUT:HL = ROOM DATA WHEN IT IS VISIBLE, 0 IN OTHER CASE
;	Z = 1 WHEN IT IS NOT VISIBLE

	CSEG
	PUBLIC	GETRINFO
	EXTRN	ADDAHL

GETRINFO:
	LD	HL,(LEVEL)
	CALL	DCOMPR
	JR	NZ,G.NOK		;DIFFERENT LEVEL, SO NO RINFO

	LD	IY,RINFO
	LD	E,C
	LD	D,B
	LD	B,NR_RINFO

R.LOOP:	LD	A,E			;IS IT THE SAME ROOM?
	CP	(IY+RINFO.ROOM)
	JR	NZ,R.NEXT
	LD	A,D
	CP	(IY+RINFO.ROOM+1)
	JR	NZ,R.NEXT
	PUSH	IY			;OK, RETURN IT
	POP	HL
	OR	1			;SET Z=0
	RET

R.NEXT:	EXX
	LD	DE,SIZRINFO
	ADD	IY,DE
	EXX
	DJNZ	R.LOOP

G.NOK:	LD	HL,0			;I'M SORRY, YOU ARE NOT SHOWED
	CP	A			;SET Z=1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
;INPUT:	E = PALETE NUMBER
;OUTPUT:HL = PALETE DATA

	CSEG
	PUBLIC	GETPAL

GETPAL:	EX	DE,HL
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,PALETES
	ADD	HL,DE
	JP	PUTLPAGE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = LEVEL NUMBER

	CSEG
	PUBLIC	LDLEVEL
	EXTRN	SETPAL,GETLEVEL

LDLEVEL:CALL	GETLEVEL		;GET THE LEVEL DEFINITION STRUCTURE
	RET	Z
	PUSH	HL
	PUSH	HL

	POP	IY
	LD	E,(IY+LVL.PAL)		;SET THE LEVEL PALETE
	CALL	GETPAL
	CALL	SETPAL

	POP	IY
	LD	E,(IY+LVL.GFX)
	CALL	LDPATSET		;LOAD THE LEVEL PATTERN SET
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	E = SET NUMBER

	CSEG
	PUBLIC	LDPATSET
	EXTRN	VLDIR,CARTPAGE

LDPATSET:LD	A,PAT0PAGE
	ADD	A,E
	LD	E,A
	CALL	CARTPAGE		;SET THE PAGE OF THE GRAPHICS
	LD	HL,CARTSEG
	LD	DE,00000H
	LD	BC,04000H
	LD	A,PATPAGE*2
	JP	VLDIR			;COPY THEM TO VRAM (256*128)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = A POINT|LEVEL|MAP
;OUTPUT:Z = 1 WHEN NO VALID POSITION

	CSEG

CHKROOM:LD	A,D
	CP	-1
	RET	Z
	CP	ROOMXSIZ
	RET	Z
	LD	A,E
	CP	-1
	RET	Z
	CP	ROOMYSIZ
	RET




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: DE = LEVEL POSITION
;	BC = ROOM POSITION
;	IY = RINFO POINTER
;	A = HEIGHT LEVEL
;OUTPUT:HL = POINTER TO THE HEIGHT MATRIX
;	Z = 1 WHEN ERROR

	CSEG
	PUBLIC	HMATRIX

HMATRIX:EX	AF,AF'			;A' = HEIGHT LEVEL
	LD	A,IYL
	OR	IYU
	LD	(G.RAM),A
	JR	Z,H.NINFO

	EX	AF,AF'			;A = HEIGHT LEVEL
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A			;A = HEIGHT*64 (MAPXSIZ*MAPYSIZ)
	LD	L,A
	LD	H,0			;HL = SIZHMATRIX*HEIGHT

	LD	E,IYL			;DE = RINFO
	LD	D,IYU
	ADD	HL,DE			;HL = RINFO + HMATRIX[HEIGHT]
	LD	DE,RINFO.HMATRIX
	ADD	HL,DE			;HL = RINFO->HMATRIX[HEIGHT]
	OR	1
	RET

H.NINFO:EX	AF,AF'			;RESTORE INPUT PARAMETERS
	CALL	GETROOM			;HL = POINTER TO MAP ADDRESS
	RET	Z
	LD	E,(HL)
	INC	HL
	LD	D,(HL)			;DE = MAP NUMBER
	LD	A,E
	OR	D
	RET	Z			;DE = MAPNO = 0 MEANS NO ROOM
	CALL	GETHMAP			;HL = HEIGHT ADDRESS (HMAP)
	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT: DE = LEVEL POSITION
;	BC = ROOM POSITION
;	HL = MAP POSITION
;	IY = RINFO POINTER
;	A = HEIGHT LEVEL
;OUTPUT:A = HEIGHT VALUE
;	HL = POINTER TO THE HEIGHT VALUE
;	Z = 1 WHEN ERROR

	CSEG
	PUBLIC	GETHEIGHT

GETHEIGHT:
	PUSH	HL
	CALL	HMATRIX			;HL = HMATRIX
	POP	DE
	RET	Z
	CALL	MOFFSET
	LD	B,(HL)			;HL = &HMATRIX[Y][X]
	LD	A,(G.RAM)
	OR	A
	JR	NZ,H.1
	LD	HL,G.RAM		;IF THE MATRIX IS IN ROM, RETURN
	LD	(HL),B
H.1:	LD	A,B			;A DUMMY POSITION
	CP	-1
	RET

	DSEG
G.RAM:	DB	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = ROOM COORDENATES
;	IY = POINTER TO THE RINFO

	CSEG
	EXTRN	GETROOM

FILLHMATRIX:
	LD	(F.ROOM),DE		;FILL THE HMATRIX OF THE RINFO
	LD	E,IYL
	LD	D,IYU
	LD	HL,RINFO.HMATRIX
	ADD	HL,DE
	EX	DE,HL
	XOR	A

M.LOOPH:LD	(F.HEIGHT),A
	LD	(F.PTR),DE
	LD	DE,(LEVEL)
	LD	BC,(F.ROOM)
	LD	A,(F.HEIGHT)
	CALL	GETROOM			;GET THE MAP NUMBER
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	A,E
	OR	D
	RET	Z			;MAPNO = 0 MEANS EMPTY MAP
	CALL	GETHMAP			;GET THE ADDRESS OF THE HMATRIX
	LD	DE,(F.PTR)
	LD	BC,SIZHMATRIX
	LDIR
	LD	A,(F.HEIGHT)
	INC	A
	CP	NR_HEIGHTS
	JR	NZ,M.LOOPH
	RET

	DSEG
F.HEIGHT:	DB	0
F.ROOM:		DW	0
F.PTR:		DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = LEVEL
;	BC = ROOM

	CSEG
	PUBLIC	FOCUSCAM
	EXTRN	DELSPR,MOUSE,MAP,CLRVPAGE,CPVPAGE,GETHMAP,SHOWDOORS

FOCUSCAM:
	LD	(LEVEL),DE
	LD	(ROOM),BC
	PUSH	DE
	PUSH	BC
	LD	DE,(ACPAGE)
	CALL	CLRVPAGE		;CLEAR ACTIVE PAGE
	XOR	A
	CALL	MOUSE			;DISABLE MOUSE AND CLEAN SPRITES
	CALL	DELSPR
	POP	BC
	POP	DE
	CALL	MAP			;MAP THE ROOM IN ACTIVE PAGE
	LD	DE,(ACPAGE)
	LD	BC,(DPPAGE)
	CALL	CPVPAGE			;COPY FROM ACTIVE PAGE TO DISPLAY PAGE

	LD	IY,RINFO
	LD	B,NR_RINFO

M.LOOP:	PUSH	BC
	PUSH	IY

	LD	DE,(ROOM)
	LD	L,(IY+RINFO.INC)
	LD	H,(IY+RINFO.INC+1)	;HL=ROOM INCREMENTS
	LD	A,E
	ADD	A,L
	LD	E,A
	LD	A,D
	ADD	A,H
	LD	D,A
	CALL	CHKROOM
	LD	(IY+RINFO.ROOM),E	;DE = NEW ROOM LOCATION
	LD	(IY+RINFO.ROOM+1),D
	CALL	FILLHMATRIX

	POP	IY
	LD	DE,SIZRINFO
	ADD	IY,DE			;IY POINTING TO NEXT RINFO
	POP	BC
	DJNZ	M.LOOP
	CALL	SHOWDOORS		;SHOW THE DOORS IN THE VISIBLE ROOMS
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	DSEG

RINFO:	DS	SIZRINFO*NR_RINFO
LEVEL:	DW	0
ROOM:	DW	0



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	PATHFINDER
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = COORDENATE 1
;	BC = COORDENATE 2
;OUTPUT:A = DISTANCE BETWEEN BOTH POINTS
;	Z = 1 WHEN DE == BC
;MODIFY:H

	CSEG

DISTANCE:
	LD	A,D
	SUB	B
	JP	P,D.1
	NEG
D.1:	LD	H,A
	LD	A,E
	SUB	C
	JP	P,D.2
	NEG
D.2:	ADD	A,H
	RET				;A = ABS(P1.X-P2.X) + ABS(P1.Y-P2.Y)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = A POINT|LEVEL|MAP
;OUTPUT:Z = 1 WHEN NO VALID POSITION
;THIS FUNCTION WORKS WITH POINTS, LEVEL AND MAP BECAUSE THE
;SIZE OF ALL OF THEM IS THE SAME, SO WE CAN USE MAPXSIZ OR
;ROOMXSIZ THAT WORKS

	CSEG


ISGOOD:	LD	HL,(GOODFUN)
	JP	(HL)

CSEARCH:LD	A,D
	CP	-1
	RET	Z
	CP	MAPXSIZ
	RET	Z
	LD	A,E
	CP	-1
	RET	Z
	CP	MAPYSIZ
	RET

RSEARCH:LD	A,D
	CP	MAPXSIZ
	RET	Z
	LD	A,E
	CP	-1
	RET	Z
	CP	MAPYSIZ
	RET

LSEARCH:LD	A,D
	CP	-1
	RET	Z
	LD	A,E
	CP	-1
	RET	Z
	CP	MAPYSIZ
	RET

DSEARCH:LD	A,D
	CP	-1
	RET	Z
	CP	MAPXSIZ
	RET	Z
	LD	E,A
	CP	MAPYSIZ
	RET

USEARCH:LD	A,D
	CP	-1
	RET	Z
	CP	MAPXSIZ
	RET	Z
	LD	A,E
	CP	-1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = A POINT
;OUTPUT:Z = 1 WHEN NO ACCESSIBLE

	CSEG

ISACCESS:
	LD	HL,(P.MATRIX)
	CALL	MOFFSET			;HL = P.MATRIX + Y*MAPYSIZ +X
	LD	A,(HEIGHT)
	LD	B,A
	LD	A,(HL)
	SUB	B
	JP	P,A.POS
	NEG
A.POS:	CP	2
	JR	C,A.OK
	XOR	A
	RET
A.OK:	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	HL = MARK POINTER
;	DE = A POINT
;	C = DIRECTION OF THIS NODE
;OUTPUT:Z = 1 WHEN NO VALID NODE

	CSEG

ISMARKED:
	LD	A,E		;WE CAN GET INVALID POINTS WHEN
	CP	-1		;WE MOVE FROM ONE ROOM TO OTHER ROOM
	JR	Z,ISM.OK	;SINCE ISGOOD ALREADY FILTER THE BAD
	CP	ROOMYSIZ	;NODES WE CAN JUST IGNORE OUT OF MAP
	JR	Z,ISM.OK	;NODES

	LD	A,D
	CP	-1
	JR	Z,ISM.OK
	CP	ROOMXSIZ
	JR	Z,ISM.OK
I.1:
	LD	A,(HL)
	CP	-1
	RET	NZ
	LD	(HL),C			;MARK THIS NODE AS VISITED
	RET				;USE THE DIRECTION

ISM.OK:	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;OUTPUT:HL = POINTER TO NODE
;	Z = 1 WHEN NO MORE AVAIBLE NODES

	CSEG
	EXTRN	PTRHL

GETBEST:LD	HL,(BESTP)
	LD	A,H
	OR	L
	RET	Z

	PUSH	HL			;TAKE IT FROM BEST QUEUE
	LD	DE,NODE.NEXT		;PTR = BESTP
	ADD	HL,DE			;BESTP = BESTP->NEXT
	CALL	PTRHL
	LD	(BESTP),HL
	LD	A,L
	OR	H
	JP	NZ,G.BEST1
	LD	HL,(BADP)		;IF !BESTP THEN
	LD	DE,(WORSTP)		;   BESTP = BADP
	LD	(BADP),DE		;   BADP = WORSTP
	LD	DE,0			;   WORSTP = TAILP = NULL
	LD	(WORSTP),DE
	LD	(TAILP),DE
G.BEST1:LD	(BESTP),HL
	POP	HL			;RETURN PTR
	OR	1
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	DE = NODE COORDENATES
;	(DESTINE) = DESTINE NODE
;	A = DISTANCE

	CSEG
	EXTRN	PTRCALL

NEWNODE:LD	BC,(DESTINE)
	CALL	DISTANCE
	RET	Z			;WE HAVE FOUND THE DESTINE, STOP

	LD	HL,STEP
	ADD	A,(HL)
	LD	(N.COST),A
	LD	HL,(NODEPTR)
	PUSH	HL
	PUSH	HL
	LD	BC,SIZNODE
	ADD	HL,BC
	LD	(NODEPTR),HL
	POP	HL
	LD	(HL),A			;STORE THE DISTANCE
	INC	HL
	LD	A,(STEP)
	LD	(HL),A			;STORE NUMBER OF STEPS
	INC	HL
	LD	(HL),E			;STORE COORDENATES
	INC	HL
	LD	(HL),D
	INC	HL
	EX	DE,HL			;DE = POINTER TO ACTUAL->NEXT
	POP	BC			;BC = ACTUAL NODE POINTER

	LD	HL,(BESTP)
	LD	A,H
	OR	L
	JP	Z,N.BEST		;BEST IS EMPTY, INSERT
	LD	A,(N.COST)
	CP	(HL)
	JP	Z,N.BEST		;COST <= BESTP->COST, INSERT
	JP	C,N.BEST

	LD	HL,(BADP)
	LD	A,H
	OR	L
	JP	Z,N.BAD			;BAD IS EMPTY, INSERT
	LD	A,(N.COST)
	CP	(HL)
	JP	Z,N.BAD			;COST <= BADP->COST, INSERT
	JP	C,N.BAD

	LD	HL,(WORSTP)
	LD	A,L
	OR	H
	JP	NZ,N.TAIL
	LD	(WORSTP),BC		;IF WORSTP == NULL
	LD	(TAILP),BC		;   TAILP = WORSTP = NODE
	JP	N.AUX			;   NODE->NEXT = NULL

N.TAIL:	LD	IY,(TAILP)		;IF WORSTP != NULL
	LD	(TAILP),BC		;   NODE->NEXT = NULL
	LD	(IY+NODE.NEXT),C	;   TAILP->NEXT = NODE
	LD	(IY+NODE.NEXT+1),B	;   TAILP = NODE
	LD	HL,0
	JP	N.AUX

N.BAD:	LD	(BADP),BC
	JP	N.AUX

N.BEST:	LD	(BESTP),BC

N.AUX:	EX	DE,HL
	LD	(HL),E
	INC	HL
	LD	(HL),D
	CALL	PDEBUG
	OR	1
	RET

	DSEG
N.COST:	DB	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	(NODE) = ACTUAL NODE
;	(HEIGHT) = NODE HEIGHT
;	(MPTR) = ACTUAL MARKED POINTER
;	(DESTINE) = DESTINE
;OUTPUT:Z = 1 WHEN WE HAVE REACHED THE DESTINE

	CSEG

ADDNODES:				;DON'T EXPAND THE ORIGIN NODE
	LD	HL,(MPTR)		;SO, DON'T TRY THE INVERSE DIRECTION
	LD	B,(HL)			;OF OUR FATHER
	INC	B

N.0:	DJNZ	N.1			;RIGHT
	CALL	A.RIGHT
	CALL	NZ,A.UP
	CALL	NZ,A.DOWN
	RET

N.1:	DJNZ	N.2			;DOWN
	CALL	A.RIGHT
	CALL	NZ,A.LEFT
	CALL	NZ,A.DOWN
	RET

N.2:	DJNZ	N.3			;UP
	CALL	A.RIGHT
	CALL	NZ,A.LEFT
	CALL	NZ,A.UP
	RET

N.3:	DJNZ	N.4
	CALL	A.LEFT			;LEFT
	CALL	NZ,A.UP
	CALL	NZ,A.DOWN
	RET

N.4:	CALL	A.RIGHT			;NODIR
	CALL	NZ,A.LEFT
	CALL	NZ,A.UP
	CALL	NZ,A.DOWN
	RET

	;IF ISGOOD && ISACCESS && ISMARKED THEN
	;   IF NEWNODE == DESTINE THEN
	;      RETURN FOUND

A.RIGHT:LD	DE,(NODE)
	INC	D
	LD	HL,(MPTR)
	INC	HL
	LD	(A.MPTR),HL
	LD	C,DRIGHT
	JR	A.TEST

A.LEFT:	LD	DE,(NODE)
	DEC	D
	LD	HL,(MPTR)
	DEC	HL
	LD	(A.MPTR),HL
	LD	C,DLEFT
	JR	A.TEST

A.UP:	LD	DE,(NODE)
	DEC	E
	LD	HL,(MPTR)
	LD	BC,-MAPYSIZ
	ADD	HL,BC
	LD	(A.MPTR),HL
	LD	C,DUP
	JR	A.TEST

A.DOWN:	LD	DE,(NODE)
	INC	E
	LD	HL,(MPTR)
	LD	BC,MAPYSIZ
	ADD	HL,BC
	LD	(A.MPTR),HL
	LD	C,DDOWN

	;THIS CODE EXPECTS DE = CHILD NODE AND C = DIR. ISGOOD,
	;ISACCESS AND ISMARKED MUST NOT MODIFY THEM
A.TEST:	CALL	ISGOOD
	JR	Z,A.SET
	CALL	ISACCESS
	JR	Z,A.SET
	LD	HL,(A.MPTR)
	CALL	ISMARKED
	RET	NZ
	CALL	NEWNODE
	RET

A.SET:	OR	1
	RET

	CSEG
A.MPTR:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO ORIGIN CHAR
;	IY = POINTER TO DESTINE MOVABLE
;OUTPUT:(IX+CHAR.PATHCNT) SIZE OF THE PATH CALCULATED
;	(IX+CHAR.PATH) PATH CALCULATED

	CSEG
	PUBLIC	PATH2MOV
	EXTRN	HPOINTER,ARYHL

PATH2MOV:
	LD	(P.SRC),IX		;SAVE SOURCE AND DESTINATION
	LD	(P.DST),IY

	PUSH	IY			;REMOVE DESTINATION MOVABLE
	POP	IX
	CALL	HPOINTER
	SUB	(IX+MOV.ZSIZ)
	LD	(HL),A

	LD	DE,MOV.POINT		;TAKE A POINTER TO THE DESTINATION
	ADD	IX,DE			;POINT
	PUSH	IX
	POP	IY

	LD	IX,(P.SRC)
	PUSH	HL
	CALL	GOTO
	POP	HL
	LD	IY,(P.DST)

	LD	A,(HL)			;RESTORE DESTINATION MOVABLE
	ADD	A,(IY+MOV.ZSIZ)
	LD	(HL),A

	RET

	DSEG
P.SRC:	DW	0
P.DST:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = POINTER TO ORIGIN CHAR
;	IY = POINTER TO DESTINE POINT
;OUTPUT:(IX+CHAR.PATHCNT) SIZE OF THE PATH CALCULATED
;	(IX+CHAR.PATH) PATH CALCULATED
	CSEG
	EXTRN	DCOMPR

GOTO:	LD	(G.MOV),IX
	LD	(G.POINT),IY
	LD	(IX+CHAR.PATHCNT),0	;SET DEFAULT RETURN
	LD	E,IXL			;SET OUTBUF AND OUTCNT VALUES
	LD	D,IXU
	LD	HL,CHAR.PATH
	ADD	HL,DE
	LD	(OUTBUF),HL
	LD	A,SIZPATH
	LD	(OUTCNT),A

	LD	E,(IX+MOV.LEVEL)
	LD	D,(IX+MOV.LEVEL+1)
	LD	L,(IY+POINT.LEVEL)
	LD	H,(IY+POINT.LEVEL+1)
	CALL	DCOMPR
	JR	Z,G.1
	CALL	GOTOL
	JR	G.END

G.1:	LD	E,(IX+MOV.ROOM)
	LD	D,(IX+MOV.ROOM+1)
	LD	L,(IY+POINT.ROOM)
	LD	H,(IY+POINT.ROOM+1)
	CALL	DCOMPR
	JR	Z,G.2
	CALL	GOTOR
	JR	G.END

G.2:	LD	E,(IY+POINT.Y)
	LD	D,(IY+POINT.X)
	LD	C,(IX+MOV.Y)
	LD	B,(IX+MOV.X)
	CALL	DISTANCE
	CP	1
	CALL	NZ,GOTOM

G.END:	LD	IX,(G.MOV)
	RET

	DSEG
G.MOV:	DW	0
G.POINT:DW	0


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOCAL SEARCH. SAME LEVEL AND SAME ROOM

	CSEG
	EXTRN	MOVHMATRIX

GOTOM:	CALL	MOVHMATRIX		;GET THE HEIGHT MATRIX
	RET	Z			;HL = HEIGHT MATRIX

	LD	DE,MOV.POINT
	ADD	IX,DE			;TAKE ADDRESS OF ORIGIN POINT
	LD	IY,(G.POINT)
	EX	DE,HL			;DE = HEIGHT MATRIX
	LD	HL,CSEARCH
	LD	(GOODFUN),HL
	CALL	PSEARCH
	RET	Z

	LD	IX,(G.MOV)
	LD	A,(OUTCNT)
	LD	B,A
	LD	A,SIZPATH
	SUB	B
	LD	(IX+CHAR.PATHCNT),A
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	CSEG

GOTOL:	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	CSEG
	EXTRN	GETLEVEL,MOVHMATRIX

GOTOR:	LD	A,(IY+POINT.LEVEL)
	LD	(G.DST+POINT.Y),A
	LD	A,(IY+POINT.LEVEL+1)
	LD	(G.DST+POINT.X),A
	LD	A,(IX+MOV.LEVEL)
	LD	(G.SRC+POINT.Y),A
	LD	E,A
	LD	A,(IX+MOV.LEVEL+1)
	LD	(G.SRC+POINT.X),A
	LD	D,A
	CALL	GETLEVEL
	RET	NZ

	LD	DE,LVL.ACCESS
	ADD	HL,DE
	LD	IX,G.SRC
	LD	IY,G.DST
	CALL	PSEARCH
	RET	Z

	CALL	GETPATH		;TODO: ADD HL AS OUTPUT OF GETPATH
	LD	A,SIZPATH
	LD	(OUTCNT),A
	LD	B,(HL)		;B = LEVEL DIRECTION
	INC	B
	LD	DE,0

GR.RIGT:DJNZ	GR.DOWN
	LD	D,ROOMXSIZ
	JR	GR.DST

GR.DOWN:DJNZ	GR.UP
	LD	E,-1
	JR	GR.DST

GR.UP:	DJNZ	GR.LEFT
	LD	E,ROOMYSIZ
	JR	GR.DST

GR.LEFT:LD	D,-1
GR.DST:	LD	A,E
	LD	(G.DST+POINT.Y),A
	LD	A,D
	LD	(G.DST+POINT.X),A
	CALL	MOVHMATRIX
	LD	DE,MOV.POINT
	ADD	IX,DE
	LD	IY,G.DST
	CALL	PSEARCH
	RET	Z

	LD	IX,(G.MOV)
	LD	A,(OUTCNT)
	LD	B,A
	LD	A,SIZPATH
	SUB	B
	LD	(IX+CHAR.PATHCNT),A
	RET

	CSEG
G.SRC:	DS	SIZPOINT
G.DST:	DS	SIZPOINT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	IX = ORIGIN POINT
;	IY = DESTINE POINT
;	DE = HEIGHT MATRIX
;OUTPUT:Z = 1 WHEN NO PATH

	CSEG
	PUBLIC	PSEARCH
	EXTRN	MEMSET,PTRCALL

PSEARCH:LD	(P.MATRIX),DE
	LD	A,(IX+POINT.Z)
	LD	(HEIGHT),A
	LD	E,(IX+POINT.Y)
	LD	D,(IX+POINT.X)
	LD	(ORIGIN),DE		;INITIALIZE ORIGIN
	LD	(NODE),DE
	LD	C,(IY+POINT.Y)
	LD	B,(IY+POINT.X)
	LD	(DESTINE),BC		;INITIALIZE DESTINE
	CALL	DISTANCE
	RET	Z			;IT IS THE SAME POINT, RETURN

	LD	HL,0
	LD	(BESTP),HL		;AND DATA POINTERS
	LD	(BADP),HL
	LD	(WORSTP),HL
	LD	(TAILP),HL
	LD	A,1
	LD	(STEP),A
	LD	HL,NODEBUF
	LD	(NODEPTR),HL
	LD	HL,MARKBUF		;CLEAR MARK BUF
	LD	BC,MAPYSIZ*MAPXSIZ
	LD	A,-1
	CALL	MEMSET

	LD	HL,MARKBUF		;MARK AS EXPLORED THE ORIGIN
	LD	DE,(ORIGIN)
	CALL	MOFFSET
	LD	(HL),DNODIR
	LD	(MPTR),HL		;MPTR = MARKBUF + Y*MAPYSIZ + X

P.LOOP:	CALL	ADDNODES
	JP	NZ,P.NEXT
	CALL	GETPATH
	OR	1
	RET

P.NEXT:	CALL	PDEBUG
	CALL	GETBEST			;GET THE BEST NODE
	RET	Z
	INC	HL
	LD	A,(HL)
	INC	A
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	LD	(STEP),A
	LD	(NODE),DE
	LD	HL,MARKBUF
	CALL	MOFFSET
	LD	(MPTR),HL		;MPTR = MARKBUF + Y*MAPYSIZ + X
	LD	HL,(P.MATRIX)
	CALL	MOFFSET			;HL = (P.MATRIX) + Y*MAPYSIZ + X
	LD	A,(HL)
	LD	(HEIGHT),A
	JP	P.LOOP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	EXTRN	ADDAHL

MOFFSET:LD	A,E			;CALCULATE THE OFFSET IN A MAP
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,D
	JP	ADDAHL

	DSEG
P.MATRIX:	DW	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;INPUT:	(DESTINE) = DESTINE LOCATION
;	(ORIGIN) = ORIGIN LOCATION
;	(OUTBUF) = POINTER TO OUTPUT BUFFER
;	(OUTCNT) = SIZE OF OUTPUT BUFFER

	CSEG

GETPATH:LD	DE,(DESTINE)
	CALL	PXXX
	LD	(OUTCNT),A
	RET

PXXX:	LD	HL,(ORIGIN)
	CALL	DCOMPR
	JR	NZ,X.0
	LD	HL,(OUTBUF)
	LD	A,(OUTCNT)
	RET

X.0:	LD	HL,MARKBUF
	CALL	MOFFSET			;TAKE THE ADDRESS OF THE POSITION IN
	LD	B,(HL)			;THE MARK BUFFER
	INC	B

X.RIGHT:DJNZ	X.DOWN
	DEC	D
	CALL	PXXX
	LD	B,DRIGHT
	JR	ADDSTEP

X.DOWN:	DJNZ	X.UP
	DEC	E
	CALL	PXXX
	LD	B,DDOWN
	JR	ADDSTEP

X.UP:	DJNZ	X.LEFT
	INC	E
	CALL	PXXX
	LD	B,DUP
	JR	ADDSTEP

X.LEFT:	DJNZ	X.RET
	INC	D
	CALL	PXXX
	LD	B,DLEFT

ADDSTEP:OR	A
	RET	Z
	DEC	A
	LD	(HL),B
	INC	HL
X.RET:	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	CSEG
	EXTRN	CLRVPAGE,LOCATE,PRINTF,VDPSYNC,KPRESS

	INCLUDE	BIOS.INC

PDEBUG:	RET
	LD	A,(ACPAGE)
	PUSH	AF
	LD	A,(DPPAGE)
	LD	(ACPAGE),A
	LD	E,A
	CALL	CLRVPAGE

	LD	DE,0
	CALL	LOCATE

	LD	DE,(DESTINE)
	LD	H,0
	LD	L,E
	PUSH	HL
	LD	L,D
	PUSH	HL
	LD	DE,(NODE)
	LD	H,0
	LD	L,E
	PUSH	HL
	LD	L,D
	PUSH	HL
	LD	DE,P.FMT1
	CALL	PRINTF

	LD	DE,1
	LD	IY,(BESTP)
	CALL	P.AUX

	LD	DE,20*256+1
	LD	IY,(BADP)
	CALL	P.AUX

	LD	DE,40*256+1
	LD	IY,(WORSTP)
	CALL	P.AUX

	CALL	VDPSYNC
	CALL	KPRESS
	POP	AF
	LD	(ACPAGE),A
	RET

P.FMT1:	DB	"NODE=%02dX%02d,DESTINE=%02dX%02d",0

P.AUX:	LD	A,IYL
	OR	IYU
	RET	Z

	PUSH	DE
	PUSH	IY
	PUSH	IY
	CALL	LOCATE
	POP	IY
	LD	B,0
	LD	C,(IY+NODE.Y)
	PUSH	BC
	LD	C,(IY+NODE.X)
	PUSH	BC
	LD	C,(IY+NODE.STEP)
	PUSH	BC
	LD	C,(IY+NODE.COST)
	PUSH	BC
	LD	DE,P.FMT2
	CALL	PRINTF

	POP	IY
	LD	E,(IY+NODE.NEXT)
	LD	D,(IY+NODE.NEXT+1)
	LD	IYL,E
	LD	IYU,D
	POP	DE
	INC	E
	JR	P.AUX

P.FMT2:	DB	"C=%02d,S=%02d,P=%02dX%02d--",0




;;;;;;;;;;;;

NODE.COST	EQU	0
NODE.STEP	EQU	NODE.COST+1
NODE.Y		EQU	NODE.STEP+1
NODE.X		EQU	NODE.Y+1
NODE.NEXT	EQU	NODE.X+1
SIZNODE		EQU	NODE.NEXT+2


	DSEG

STEP:	DB	0
GOODFUN:DW	0
NODE:	DW	0
HEIGHT:	DB	0
MPTR:	DW	0
ORIGIN:	DW	0
DESTINE:DW	0
NODEPTR:DW	0
BESTP:	DW	0
BADP:	DW	0
WORSTP:	DW	0
TAILP:	DW	0
OUTBUF:	DW	0
OUTCNT:	DB	0
MARKBUF:DS	MAPXSIZ*MAPYSIZ
NODEBUF:DS	SIZNODE*MAPXSIZ*MAPYSIZ


